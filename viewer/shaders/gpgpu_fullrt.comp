#version 430 core

layout(binding = 2, rgba32f) uniform writeonly image2D framebuffer;

uniform float eta;
uniform vec3 center;
uniform float radius;
uniform bool blinnPhong;
uniform float shininess;
uniform mat4 mat_inverse;
uniform bool transparent;
uniform vec3 lightPosition;
uniform mat4 persp_inverse;
uniform float groundDistance;
uniform float lightIntensity;
uniform sampler2D colorTexture;

#define MAX_SCENE_BOUNDS    10.0
#define EPS                 0.000001

#define MIN_DISTANCE EPS
#define GROUND_VPTR -1

#define M_1_PI 0.31830988618
#define PI 3.141592653589793

#define Ka 0.05
#define Kd 0.3
float alpha = shininess;

struct hitinfo_t {
	// Index of the first index of the triangle, or: GROUND_VPTR.
	int hit_vptr;

	// Intersection distance, barycentric coordinates or: intersection distance,
	// 0, texture coordinates (for the ground).
	vec4 t;
};

struct BVHNode {
	vec4 min;
	vec4 max;
	int nbTriangles;
	int index;
};

layout (std430, binding = 1) buffer Vertices { vec4 vertices[]; };

layout (std430, binding = 2) buffer Normals { vec4 normals[]; };

layout (std430, binding = 3) buffer Colors { vec4 colors[]; };

layout (std430, binding = 4) buffer Meshes { int indices[]; };

layout (std430, binding = 5) buffer BVHNodes { BVHNode nodes[]; };


// Checks whether there is an intersection between the ray (origin, dir) and the
// bounding box (bbmin, bbmax). Stores into tNear the nearest point of
// intersection on the ray.
bool intersectBoundingBox(vec4 origin, vec4 dir, vec4 bbmin, vec4 bbmax,
							out float tNear)
{

	// Intersect with BB.
	vec4 sMin = (bbmin - origin) / dir;
	vec4 sMax = (bbmax - origin) / dir;

	vec4 tMin = min(sMin, sMax);
	vec4 tMax = max(sMin, sMax);

	tNear = max(max(tMin.x, tMin.y), tMin.z);
	float tFar = min(min(tMax.x, tMax.y), tMax.z);

	if (tNear < 0)
		tNear = 0; // Starting point inside the BVH.
	
	return tNear <= tFar;

}

// Intersect ray (origin, dir) with triangle defined by ptr (number inside the
// indexed face set) returns a boolean, plus the "t" of hitinfo structure.
bool intersectTriangle(vec4 origin, vec4 dir, int ptr, out vec4 dist)
{

	// Vertices from the data.
	vec4 v0 = vertices[indices[ptr]];
	vec4 v1 = vertices[indices[ptr + 1]];
	vec4 v2 = vertices[indices[ptr + 2]];

	vec3 e1 = (v1 - v0).xyz;
	vec3 e2 = (v2 - v0).xyz;

	vec3 p = cross(dir.xyz, e2);
	float det = dot(e1, p);
	if (abs(det) < EPS)
		return false;

	// We do early exit here: as soon as we can return false, we do.
	// In my tests, it is faster than computing all coordinates, 
	// *then* checking validity with a single test. YMMV, feel free to test.
	vec3 t = (origin - v0).xyz;
	dist.y = dot(t, p);
	if (dist.y < 0.0 || dist.y > det)
		return false;

	vec3 q = cross(t, e1);
	dist.z = dot(dir.xyz, q);
	if (dist.z < 0.0 || dist.z > det)
		return false;
	
	dist.w = det - dist.y - dist.z;
	if (dist.w < 0.0)
		return false;
	
	dist.x = dot(e2, q);
	dist /= det;
	
	return (dist.x > EPS);

}

bool intersectGround(vec4 origin, vec4 dir, out vec4 dist)
{

	if (abs(dir.y) < EPS)
		return false;
	
	float t = -(origin.y + groundDistance) / dir.y;
	if (t < MIN_DISTANCE)
		return false;

	vec4 point = origin + t * dir;
	point.y = -groundDistance;
	vec4 scaledPoint = point / radius ;
	vec2 texCoords = 0.5 * scaledPoint.xz + 0.5;
	dist = vec4(t, 0.0, texCoords);

	return true;

}

vec4 interpolateColor(hitinfo_t h)
{

	if (colors.length() > 0) {
		vec4 c0 = colors[indices[h.hit_vptr]];
		vec4 c1 = colors[indices[h.hit_vptr + 1]];
		vec4 c2 = colors[indices[h.hit_vptr + 2]];
		return (h.t.w * c0 + h.t.y * c1 + h.t.z * c2);
	} else
		return vec4(0.7, 0.7, 0.7, 1.0);

}

// Heavily inspired by interpolateColor.
// Don't know if this is correct or not.
vec4 interpolateNormal(hitinfo_t h)
{

	vec4 res;

	if (normals.length() > 0) {
		vec4 n0, n1, n2;
		n0 = normals[indices[h.hit_vptr]];
		n1 = normals[indices[h.hit_vptr + 1]];
		n2 = normals[indices[h.hit_vptr + 2]];
		res = (h.t.w * n0 + h.t.y * n1 + h.t.z * n2);
	} else {
		res = vec4(1.0, 0.0, 0.0, 1.0);
	}

	return normalize(res);

}

/* ---------------------------------- BVH ----------------------------------- */
bool isLeaf(BVHNode node) { return node.nbTriangles != 0; }

bool intersectBVHLeaf(BVHNode node, vec4 origin, vec4 dir, inout hitinfo_t h)
{

	bool hit = false;

	for (int i = 0; i < node.nbTriangles; ++i) {
		vec4 dist;
		int vptr = 3 * (node.index + i);
		if (intersectTriangle(origin, dir, vptr, dist) && dist.x < h.t.x) {
			hit = true;
			h.hit_vptr = vptr;
			h.t = dist;
		}
	}

	return hit;

}

bool intersectBVHLeaf(BVHNode node, vec4 origin, vec4 dir)
{

	for (int i = 0; i < node.nbTriangles; ++i) {
		vec4 dist;
		int vptr = 3 * (node.index + i);
		if (intersectTriangle(origin, dir, vptr, dist))
			return true;
	}

	return false;

}

#define MAX_STACK_SIZE 64
#define push(stack, size, value) stack[size++] = value
#define pop(stack, size) stack[--size]

bool intersectBVH(vec4 origin, vec4 dir, inout hitinfo_t h)
{

	int rootIndex = 0;
	BVHNode rootNode = nodes[rootIndex];
	float tNear;

	if (!intersectBoundingBox(origin, dir, rootNode.min, rootNode.max, tNear))
		return false;

	struct StackElement {
		int index;
		float t;
	} stack[MAX_STACK_SIZE];
	
	int size = 0;
	push(stack, size, StackElement(rootIndex, 0.0));

	bool hit = false;
	while (size != 0) {
		StackElement current = pop(stack, size);

		if (h.t.x < current.t)
			continue;

		BVHNode currentNode = nodes[current.index];
	
		if (isLeaf(currentNode))
			hit = intersectBVHLeaf(currentNode, origin, dir, h) || hit;
		else {
			StackElement left = StackElement(current.index + 1, 0.0);
			BVHNode leftNode = nodes[left.index];
			bool hitLeft = intersectBoundingBox(
				origin, dir, leftNode.min, leftNode.max, left.t
			);

			StackElement right = StackElement(currentNode.index, 0.0);
			BVHNode rightNode = nodes[right.index];
			bool hitRight = intersectBoundingBox(
				origin, dir, rightNode.min, rightNode.max, right.t
			);

			if (hitLeft && hitRight) {
				if (left.t < right.t) {
					push(stack, size, right);
					push(stack, size, left);
				} else {
					push(stack, size, left);
					push(stack, size, right);
				}
			} else if (hitLeft)
				push(stack, size, left);
			else if (hitRight)
				push(stack, size, right);
		}
	}

	return hit;

}

bool intersectBVH(vec4 origin, vec4 dir)
{

	int rootIndex = 0;
	BVHNode rootNode = nodes[rootIndex];
	float tNear;

	if (!intersectBoundingBox(origin, dir, rootNode.min, rootNode.max, tNear))
		return false;

	int stack[MAX_STACK_SIZE];
	int size = 0;
	push(stack, size, rootIndex);

	while (size != 0) {
		int current = pop(stack, size);
		BVHNode currentNode = nodes[current];

		if (isLeaf(currentNode)) {
			if (intersectBVHLeaf(currentNode, origin, dir))
				return true;
		} else {
			int left = current + 1;
			BVHNode leftNode = nodes[left];
			bool hitLeft = intersectBoundingBox(
				origin, dir, leftNode.min, leftNode.max, tNear
			);

			int right = currentNode.index;
			BVHNode rightNode = nodes[right];
			bool hitRight = intersectBoundingBox(
				origin, dir, rightNode.min, rightNode.max, tNear
			);

			if (hitLeft && hitRight) {
				push(stack, size, right);
				push(stack, size, left);
			} else if (hitLeft)
				push(stack, size, left);
			else if (hitRight)
				push(stack, size, right);
		}
	}

	return false;

}
/* -------------------------------- BVH End --------------------------------- */

// Compute the first intersection along the ray (origin, dir).
// Returns the nearest intersection in h.
bool firstIntersection(vec4 origin, vec4 dir, out hitinfo_t h)
{

	h.t.x = radius * MAX_SCENE_BOUNDS;

	bool hit = intersectBVH(origin, dir, h);

	vec4 dist;
	if (intersectGround(origin, dir, dist) && dist.x < h.t.x) {
		hit = true;
		h.hit_vptr = GROUND_VPTR;
		h.t = dist;
	}

	return hit;

}

// Checks whether there is any intersection along the ray (origin, dir).
// Does not compute the nearest intersection, ends the loop as soon as an
// intersection is found.
bool isIntersected(vec4 origin, vec4 dir)
{

	vec4 dist;
	return intersectGround(origin, dir, dist) || intersectBVH(origin, dir);

}

/* --------------------------- Local illumination --------------------------- */
float fresnel_coefficient(float theta)
{

	float coefficient;
	float f_s, f_p;
	float eta_2, sin_theta_2, c_i;

	eta_2 = eta * eta;
	sin_theta_2 = pow(sin(theta), 2);
	if (eta_2 < sin_theta_2) // Prevents the render from going black.
		return 1;

	c_i = sqrt((eta_2 - pow(sin(theta), 2)));

	f_s = abs((cos(theta) - c_i) / (cos(theta) + c_i));
	f_p = abs((eta_2 * cos(theta) - c_i) / (eta_2 * cos(theta) + c_i));
	f_s *= f_s;
	f_p *= f_p;

	coefficient = (f_s + f_p) / 2;

	return coefficient;

}

// Chi Distribution
int chi(float theta)
{

	if (0 <= theta && theta <= PI / 2)
		return 1;
	else
		return 0;

}

// Micro-Facet Normal Distribution
float mf_norm_dist(float theta)
{

	float term1, term2;
	float alpha_2;
	//float shininess_2;

	alpha_2 = alpha * alpha;
	//shininess_2 = shininess * shininess;

	term1 = chi(theta) / (PI * pow(cos(theta), 4));
	term2 = alpha_2 / pow(alpha_2 + pow(tan(theta), 2), 2);

	return term1 * term2;

}

float g1(float theta)
{ return 2 / (1 + sqrt(1 + (alpha * alpha) * pow(tan(theta), 2))); }

// Computes the direct illumination, at point p, from the light source at
// lightPosition. The local material has a color 'color', the normal at point p
// is n, and v is the viewing direction (pointing towards the eye).
vec4 directIllumination(vec4 color, vec4 p, vec4 n, vec4 v)
{

	// TODO: Somehow incorporate the shininess exponent into the Cook-Torrance
	// 		 Model.
	float c_a, c_d, c_s;
	vec4 lightDirection, halfVector;
	float theta_h, theta_d, theta_i, theta_o;

	lightDirection	= normalize(vec4(lightPosition, 0.0) - p);
	halfVector		= normalize(v + lightDirection);
	
	theta_h = dot(halfVector, n);
	theta_d = dot(halfVector, lightDirection);

	theta_i = dot(n, lightDirection);
	theta_o = dot(n, v);

	c_a = Ka * lightIntensity;
	c_d = Kd * max(dot(n, lightDirection), 0) * lightIntensity;

	if (blinnPhong) {
		float s = shininess * 100.0;
		c_s = fresnel_coefficient(theta_d) * pow(max(dot(n, halfVector), 0), s) * lightIntensity;
	} else { // Cook-Torrance Model
		c_s = (fresnel_coefficient(theta_d) * mf_norm_dist(theta_h) * g1(theta_i) * g1(theta_o)) / (4 * cos(theta_i) * cos(theta_o));
	}
	return color * (c_a + c_d + c_s);

}

const int MAX_TRACE = 3;

void getLocal(vec4 origin, vec4 dir, hitinfo_t h, 
			  out vec4 color, out vec4 p, out vec4 n)
{

	p = origin + h.t.x * dir;

	if (h.hit_vptr == GROUND_VPTR) {
		color = texture(colorTexture, h.t.pq);
		p.y = -groundDistance;
		n = vec4(0.0, 1.0, 0.0, 0.0);
	} else {
		color = interpolateColor(h);
		n = interpolateNormal(h);
	}

	return;

}

struct trace_state_t {
	vec4 origin;  		// Start of ray.
	vec4 dir;     		// Direction.
	vec4 color;			// Color after multiple bounces.
	vec4 localColor;	// Color of the material (after interpolation).
	hitinfo_t h;  		// What the ray hits (triangle Id, u, v, lambda).
	vec4 hit;     		// Point the ray hits.
	vec4 Ld;      		// Direction to light at destination.
	vec4 N;       		// Normal at destination.
};

vec4 trace(vec4 origin, vec4 dir)
{

	// These variables are for TP2.
	trace_state_t stack[MAX_TRACE + 1];
	bool fallback[MAX_TRACE + 1];
	int sp = 0;

	// These are for TP1.
	hitinfo_t hl;
	vec4 hit;
	vec4 localColor;
	vec4 N;

	float specular_factor, LdN;

	if (firstIntersection(origin, dir, hl)) {
		getLocal(origin, dir, hl, localColor, hit, N);
		return directIllumination(localColor, hit, N, -dir);
	} else
		return vec4(0, 0, 0, 1);

}
/* ------------------------- Local illumination End ------------------------- */

layout (local_size_x = 8, local_size_y = 8) in;

void main(void) {

	// Convert local screen coordinates into world coordinates.
	ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(framebuffer);
	if (pix.x >= size.x || pix.y >= size.y)
		return;

	vec2 pos = pix / (size - vec2(0.5, 0.5));
	// pos in [0,1]^2 need it in [-1,1]^2.
	pos = 2 * pos - vec2(1., 1.);

	// Step 1: I need pixel coordinates.
	vec4 worldPos = vec4(pos.x, pos.y, 1.0, 1.0);
	worldPos = persp_inverse * worldPos;
	worldPos /= worldPos.w;
	worldPos.w = 0;
	worldPos = normalize(worldPos);

	// Step 2: Ray direction:
	vec4 dir = normalize((mat_inverse * worldPos));
	vec4 eye = (mat_inverse * vec4(0, 0, 0, 1));
	vec4 color = trace(eye, dir);

	imageStore(framebuffer, pix, color);

}
